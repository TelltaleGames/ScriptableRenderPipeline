// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TelltaleContactShadow                    CONTACT_SHADOW=TelltaleContactShadow
#pragma kernel TelltaleContactShadow_Normals            CONTACT_SHADOW=TelltaleContactShadow_Normals	        ENABLE_NORMALS

#define OUTPUT_MASK_IDS 0

#ifdef ENABLE_NORMALS
#   define LIGHTLOOP_TILE_PASS 1
#   define USE_FPTL_LIGHTLIST  1 // deferred opaque always use FPTL
#   define UNITY_MATERIAL_LIT
#else
#   define SHADOW_USE_ONLY_VIEW_BASED_BIASING 1   // Enable only light view vector based biasing. If undefined, biasing will be based on the normal and calling code must provide a valid normal.
#endif

#ifdef SHADER_API_PSSL
#   pragma argument( scheduler=minpressure ) // instruct the shader compiler to prefer minimizing vgpr usage
#endif

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "../ShaderVariables.hlsl"
#include "Lighting.hlsl" 

#pragma only_renderers d3d11 ps4 xboxone vulkan metal

//#pragma enable_d3d11_debug_symbols

StructuredBuffer<TelltaleLightShadowData> _TelltaleShadowLights;
Texture2D<float> _TelltaleShadowMaskIds;
RWTexture2D<float4> _DeferredShadowTextureUAV; 

CBUFFER_START(DeferredShadowParameters)
float4  _ScreenSpaceShadowsParameters;
int     _SampleCount;
CBUFFER_END

#define _ContactShadowLength                _ScreenSpaceShadowsParameters.x
#define _ContactShadowDistanceScaleFactor   _ScreenSpaceShadowsParameters.y
#define _ContactShadowFadeEnd               _ScreenSpaceShadowsParameters.z
#define _ContactShadowFadeOneOverRange      _ScreenSpaceShadowsParameters.w

#define DEFERRED_SHADOW_TILE_SIZE 16
#define SHADOW_LIGHT_STRIDE 3

float inScreen(float2 v) {
    float2 s = step(float2(0, 0), v) - step(float2(1, 1), v);
    return s.x * s.y;
}

// Return 1.0 if occluded 0.0 if not
float ScreenSpaceShadowRayCast(float3 positionWS, float3 rayDirection, float rayLength, float linearDepth, int maskId)
{
	uint3 hashInput = uint3(abs(GetAbsolutePositionWS(positionWS)) * 100000 * _Time.x);
	// Dither pattern is shifted by 0.5 because we want to jitter the ray starting position backward and forward (so we need values between -0.5 and 0.5)
	float ditherBias = 0.5;
	float dither = GenerateHashedRandomFloat(hashInput) - ditherBias;

	float3 rayStartWS = positionWS;
	float3 rayEndWS = rayStartWS + rayDirection * rayLength;

	float4 rayStartCS = TransformWorldToHClip(rayStartWS);
	float4 rayEndCS = TransformWorldToHClip(rayEndWS);

	// Here we compute a ray perpendicular to view space. This is the ray we use to compute the threshold for rejecting samples.
	// This is done this way so that the threshold is less dependent of ray slope.
	float4 rayOrthoViewSpace = rayStartCS + mul(GetViewToHClipMatrix(), float4(0, 0, rayLength, 0));
	rayOrthoViewSpace = rayOrthoViewSpace / rayOrthoViewSpace.w;

	rayStartCS.xyz = rayStartCS.xyz / rayStartCS.w;
	rayEndCS.xyz = rayEndCS.xyz / rayEndCS.w;

	// Pixel to light ray in clip space.
	float3 rayCS = rayEndCS.xyz - rayStartCS.xyz;

	// Depth at the start of the ray
	float startDepth = rayStartCS.z;
	// Depth range of the ray
	float rayDepth = rayCS.z;

	// Starting UV of the sampling loop
	float2 startUV = rayStartCS.xy * 0.5f + 0.5f;
	startUV.y = 1.0 - startUV.y;

	// Pixel to light ray in 
	float2 rayUV = rayCS.xy * 0.5f;
	rayUV.y = -rayUV.y;

	float step = 1.0 / _SampleCount;

	float occluded = 0.0f;
    float compareDist = abs(rayOrthoViewSpace.z - rayStartCS.z);

    // remap .025 -> .1 to 0 -> 1
    //float ClipplaneRemap = saturate((_ContactShadowNearClipPlane - 0.025) * (1.0 / (.1 - 0.025)));
    //float bias = lerp(0.0001, 0.001, ClipplaneRemap);

    // remap linear depth to 1 -> 10
    //float remapLinDepth = saturate((linearDepth - 1.0) * (1.0 / (2.0 - 1.0)));
    //bias = lerp(bias, 0.001, remapLinDepth);

    float remapLinDepth = saturate(linearDepth);
    float bias = lerp(0.002, 0.00015, remapLinDepth);
    

	for (int i = 0; i < _SampleCount; i++)
	{
		// Step for this sample
        float lerpStep = (i + 1) * step;
        lerpStep *= lerpStep;
        float compareThreshold = compareDist * lerpStep;

        float sampleStep = lerpStep + min(lerpStep, step) * dither;

		// UVs for the current sample
        float2 sampleUV = (startUV + rayUV * sampleStep);
        if (inScreen(sampleUV) <= 0.0)
        {
            break;
        }

        uint2 maskIdCoord = sampleUV * _ScreenSize.xy;
        float sampleMaskIdFloat = _TelltaleShadowMaskIds[maskIdCoord];
        int sampleMaskId = (int)(sampleMaskIdFloat * 255.0f + 0.5f);
        if (sampleMaskId == maskId)
        {
            // Ray depth for this sample
            float raySampleDepth = startDepth + rayDepth * (sampleStep);

            // Depth buffer depth for this sample
            float sampleDepth = LOAD_TEXTURE2D(_MainDepthTexture, maskIdCoord).x;

            bool Hit = false;
            float depthDiff = sampleDepth - raySampleDepth;
            Hit = depthDiff < compareThreshold && depthDiff > bias;// 1e-4;

            if (Hit)
            {
                occluded = 1.0f;
                break;
            }
        }
	}

	// Off screen masking
	// We remove the occlusion if the ray is occluded and only if direction steps out of the screen
	//float2 vignette = max(6.0 * abs(rayStartCS.xy + rayCS.xy * occluded * 0.5) - 5.0, 0.0);
	//occluded *= saturate( 1.0 - dot(vignette, vignette) );

	return occluded;
}


float EvaluateShadowForLight(float3 lightDirection, float shadowWeight, int maskId, PositionInputs posInput)
{
    float occluded = shadowWeight * ScreenSpaceShadowRayCast(posInput.positionWS, lightDirection, .15, posInput.linearDepth, maskId);

    float distFade = saturate((4 - posInput.linearDepth) * 1);
    distFade = 1.0 - saturate(1.0 / (posInput.linearDepth * 5.0));
    return 1.0 - occluded * distFade;
}

float4 GetMaskIdColor(int maskId)
{
    float4 color = float4(0, 0, 0, 0);

    switch (maskId)
    {
    case 0:
        color = float4(0, 0, 0, 0);
        break;
    case 1:
        color = float4(1, 0, 0, 0);
        break;
    case 2:
        color = float4(0, 1, 0, 0);
        break;
    case 3:
        color = float4(0, 0, 1, 0);
        break;
    case 4:
        color = float4(1, 1, 0, 0);
        break;
    case 5:
        color = float4(0, 1, 1, 0);
        break;
    case 6:
        color = float4(1, 0, 1, 0);
        break;
    default:
        {
            uint hash = ((uint)maskId * 251);
            float level = (32 + (hash % (255-32))) / 255.0f;
            color = float4(level, level, level, 0);
        }
        break;
    }

    return color;
}

[numthreads(DEFERRED_SHADOW_TILE_SIZE, DEFERRED_SHADOW_TILE_SIZE, 1)]
void CONTACT_SHADOW(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
	uint2 pixelCoord = groupId * DEFERRED_SHADOW_TILE_SIZE + groupThreadId;
    float maskIdFloat = _TelltaleShadowMaskIds[pixelCoord];

#if !OUTPUT_MASK_IDS
    int maskId = (int)(maskIdFloat * 255.0f + 0.5f);
    if (maskId == 0)
    {
        return;
    }

    float depth = LOAD_TEXTURE2D(_MainDepthTexture, pixelCoord.xy).x;
    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        return;
    }

    uint2 tileCoord = groupId;
    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_VP, tileCoord);

    float shadow0 = EvaluateShadowForLight(_TelltaleShadowLights[maskId].direction0, _TelltaleShadowLights[maskId].weight0, maskId, posInput);
    float shadow1 = EvaluateShadowForLight(_TelltaleShadowLights[maskId].direction1, _TelltaleShadowLights[maskId].weight1, maskId, posInput);
    float shadow2 = EvaluateShadowForLight(_TelltaleShadowLights[maskId].direction2, _TelltaleShadowLights[maskId].weight2, maskId, posInput);

    _DeferredShadowTextureUAV[pixelCoord] = float4(shadow0, shadow1, shadow2, 1.0); // 1.0f in alpha indicates shadow set.
#else // !OUTPUT_MASK_IDS

    _DeferredShadowTextureUAV[pixelCoord] = GetMaskIdColor(maskId);

#endif // OUTPUT_MASK_IDS
}
