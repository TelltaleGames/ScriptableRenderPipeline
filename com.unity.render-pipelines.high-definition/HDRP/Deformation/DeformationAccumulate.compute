// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DeformationAccumulate
#pragma kernel DeformationAccumulate_Reset

#define kNumThreads 16
#define kMaxDepth 1000.0f

#ifdef SHADER_API_PSSL
#   pragma argument( scheduler=minpressure ) // instruct the shader compiler to prefer minimizing vgpr usage
#endif

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "../ShaderVariables.hlsl"

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

//
TEXTURE2D( _DeformationDepthTexture );
RW_TEXTURE2D( float, _DeformationTexture );

CBUFFER_START( DeformationComputeParameters )
float4 _DeformationDepthParams;
int3 _DeformationTexelParams;
CBUFFER_END

//
[numthreads( kNumThreads, kNumThreads, 1 )]
void DeformationAccumulate( uint2 id : SV_DispatchThreadID )
{
    int2 srcTexelLocation = ( id + _DeformationTexelParams.xy ) & _DeformationTexelParams.z;
    float normalizedDeformedDepth = LOAD_TEXTURE2D( _DeformationDepthTexture, srcTexelLocation ).x;

    float currentDepthValue = _DeformationTexture[id];
    if( normalizedDeformedDepth != 0.0f )
    {
        float deformedDepth = normalizedDeformedDepth * _DeformationDepthParams.x + _DeformationDepthParams.y;
        currentDepthValue = min( currentDepthValue, deformedDepth );
    }
    else
    {
        currentDepthValue = min( currentDepthValue + _DeformationDepthParams.z, kMaxDepth );
    }

    _DeformationTexture[id] = currentDepthValue;
}

//
[numthreads( kNumThreads, kNumThreads, 1 )]
void DeformationAccumulate_Reset( uint2 id : SV_DispatchThreadID )
{
    int2 srcTexelLocation = ( id + _DeformationTexelParams.xy ) & _DeformationTexelParams.z;
    float normalizedDeformedDepth = LOAD_TEXTURE2D( _DeformationDepthTexture, srcTexelLocation ).x;

    float currentDepthValue = kMaxDepth;
    if( normalizedDeformedDepth != 0.0f )
    {
        currentDepthValue = normalizedDeformedDepth * _DeformationDepthParams.x + _DeformationDepthParams.y;
    }
    
    _DeformationTexture[id] = currentDepthValue;
}
